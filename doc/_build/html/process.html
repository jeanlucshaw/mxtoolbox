
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>mxtoolbox.process &#8212; mxtoolbox April 2020 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to mxtoolbox’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-mxtoolbox.process">
<span id="mxtoolbox-process"></span><h1><a class="reference internal" href="#module-mxtoolbox.process" title="mxtoolbox.process"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mxtoolbox.process</span></code></a><a class="headerlink" href="#module-mxtoolbox.process" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="mxtoolbox.process.eigenvalues">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">eigenvalues</code><span class="sig-paren">(</span><em class="sig-param">args</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Function eigDec summary:</p>
<blockquote>
<div><p>Find the principal directions of variation of an ND
data scatter and return the basis change matrix.</p>
</div></blockquote>
<p>Usage:</p>
<blockquote>
<div><p>vals,vecs,B =   eigDec(args)</p>
</div></blockquote>
<p>Input:</p>
<blockquote>
<div><p>args:   tuple of same length vectors to decompose</p>
</div></blockquote>
<p>Output:</p>
<blockquote>
<div><p>vals:   sorted eigenvalues of the covariance matrix</p>
<p>vecs:   sorted eigenvectors (columns)</p>
<dl class="simple">
<dt>B<span class="classifier">basis change matrix from prior to principal</span></dt><dd><p>directions of variation.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.gaussian_smoothing">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">gaussian_smoothing</code><span class="sig-paren">(</span><em class="sig-param">xs</em>, <em class="sig-param">ys</em>, <em class="sig-param">zs</em>, <em class="sig-param">xg</em>, <em class="sig-param">yg</em>, <em class="sig-param">XR=1</em>, <em class="sig-param">YR=1</em>, <em class="sig-param">ITERS=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.gaussian_smoothing" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian smoothing filter of scattered data onto
gridded coordinates. Simplified version of the 
Barnes smoothing algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.pd_regression_statistics">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">pd_regression_statistics</code><span class="sig-paren">(</span><em class="sig-param">dataframe</em>, <em class="sig-param">xname</em>, <em class="sig-param">yname</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.pd_regression_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Print analysis of variance (ANOVA) table for a linear regression
drawn for yname from xname, two columns of dataframe. The independent
variable is considered to be xname.</p>
<p>This is based on an example from:</p>
<p>Van Emden, Helmut (2008)
Statistics for terrified biologists,
Blackwell publishing
p. 262</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_cross_correlate">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_cross_correlate</code><span class="sig-paren">(</span><em class="sig-param">da_a</em>, <em class="sig-param">da_b</em>, <em class="sig-param">coord='time'</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_cross_correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross correlation between dataarrays da_a and da_b. The
two input arrays can contain NaN values and be of different
lengths but they must have the same coordinate resolution
and coordinates must match on overlap. Resample prior to
using if necessary.</p>
<dl>
<dt>Outputs</dt><dd><dl class="simple">
<dt>tau: by how much da_a must be shifted forward</dt><dd><p>to match da_b.</p>
</dd>
</dl>
<p>r2: variance explained at maximum cross correlation</p>
<p>da_c: da_b shifted to max correlation</p>
<p>cc: cross correlation vector</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_time_aht">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_time_aht</code><span class="sig-paren">(</span><em class="sig-param">sl</em>, <em class="sig-param">h='h'</em>, <em class="sig-param">period=12.4</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_time_aht" title="Permalink to this definition">¶</a></dt>
<dd><p>Function xr_t_aht summary:</p>
<p>A much simplified version of libmx.physics.ocn.t_aht_ast</p>
<p>Serves as validation of the aforementioned code and as a fast
way to get time aht from a libmx.physics.xri.sealev xarray
object.</p>
<p>Parameters:</p>
<p>sl: sealev object
h: either ‘h’ or ‘hp’ to use measure or predicted sea level
period: defaults to 12.40 hours (semidiurnal). This adjusts
the required distance between high tides as well as the filtering
frequency.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.anomaly2rgb">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">anomaly2rgb</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.anomaly2rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an RGB triplet according to standardized anomaly value
passed as argument. Colors ar defined in intervals of 0.5 std and
saturate at -2 and 2.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.binc2edge">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">binc2edge</code><span class="sig-paren">(</span><em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.binc2edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edges from bin centers. z can be of type:</p>
<p>1- numpy.array
2- pandas.core.indexes.datetimes.DatetimeIndex
3- pandas.core.series.Series</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.hd2uv">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">hd2uv</code><span class="sig-paren">(</span><em class="sig-param">heading</em>, <em class="sig-param">magnitude</em>, <em class="sig-param">rotate_by=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.hd2uv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return u, v vector components from heading and magnitude. Heading is assumed
to start from North at 0 and rotate clockwise (90 at East). The components can
be returned in a frame of reference rotated clockwise by setting the variable
rotate_by in degrees.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.pd_add_seasons">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">pd_add_seasons</code><span class="sig-paren">(</span><em class="sig-param">dataframe</em>, <em class="sig-param">time='time'</em>, <em class="sig-param">stype='astro'</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.pd_add_seasons" title="Permalink to this definition">¶</a></dt>
<dd><p>Add season column to a dataframe containing a datetime column. The name
of the datetime column can be specified in parameter time. Astronimical
or meteorological seasons can be returned by specifiying ‘astro’ or
or ‘met’ at the stype parameter. Astronomical seasons are taken to start
on the 20th (near the solstice and equinoxes) and meteorological seasons
are given starting one the 1st of the months containing the solstices and
equinoxes.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.tetha2hd">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">tetha2hd</code><span class="sig-paren">(</span><em class="sig-param">angle</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.tetha2hd" title="Permalink to this definition">¶</a></dt>
<dd><p>Function tta2hd usage :           output    = tta2hd(angle)</p>
<p>Takes as angle angle vector in cartesian coordinates running counter-
clockwise from 0 (east) to 360 degrees and transforms it into a heading
vector running clockwise from 0 to the north to 360 degrees.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.uv2hd">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">uv2hd</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.uv2hd" title="Permalink to this definition">¶</a></dt>
<dd><p>Function uv2hd usage :          nm, hd      = uv2hd(u,v)</p>
<p>Converts vector components (u in the abscissa and v in the ordinates) of a 2D space
to a heading angle ‘hd’ in degrees with 0 towards positive y and 90 towards positive x.
Also returns the norm of vector (u,v) to variable ‘nm’.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_SA_CT_pden">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_SA_CT_pden</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">t='temperature'</em>, <em class="sig-param">s='salinity'</em>, <em class="sig-param">p='z'</em>, <em class="sig-param">lon='longitude'</em>, <em class="sig-param">lat='latitude'</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_SA_CT_pden" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an xarray dataset width added CT, SA and sigma0
columns as calculated by the Gibbs Seawater package gsw.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.broadcastable">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">broadcastable</code><span class="sig-paren">(</span><em class="sig-param">a: &lt;numpy.ndarray&gt;</em>, <em class="sig-param">b: &lt;numpy.ndarray&gt;</em><span class="sig-paren">)</span> &#x2192; list or None<a class="headerlink" href="#mxtoolbox.process.broadcastable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return shape in which b could be broadcasted with a. If arrays
can not be broadcast None is returned, therefore this function
can also serve as a boolean test answering:</p>
<p>Can b be broadcast to a through appending through prepending and
appending empty dimensions?</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.circular_distance">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">circular_distance</code><span class="sig-paren">(</span><em class="sig-param">a1</em>, <em class="sig-param">a2</em>, <em class="sig-param">units='rad'</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.circular_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function circdist usage:</p>
<blockquote>
<div><p>d   =   circdist(a1,a2,units=’rad’)</p>
</div></blockquote>
<p>Returns to ‘d’ the distance between angles a1 and a2
expected to be radians by default, or degrees if units
is specified to ‘deg’.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.distance_along_bearing">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">distance_along_bearing</code><span class="sig-paren">(</span><em class="sig-param">xpts: x input coordinates</em>, <em class="sig-param">ypts: y input coordinates</em>, <em class="sig-param">bearing: projection direction</em>, <em class="sig-param">x0: x origin = 0</em>, <em class="sig-param">y0: y origin = 0</em>, <em class="sig-param">dfunc: distance calculation function = None</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.distance_along_bearing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return distance from (<cite>x0</cite>, <cite>y0</cite>) in an arbitrary direction.</p>
<p>Project coordinates defined by (<cite>xpts</cite>, <cite>ypts</cite>) to the nearest point
on a line passing through (<cite>x0</cite>, <cite>y0</cite>) and who’s angle to the x axis
is given by <cite>bearing</cite>. Then use <cite>dfunc</cite> to calculate distance of them
projected points to the origin. The distance function is assumed to
be of the form,</p>
<blockquote>
<div><p>distance = dfunc(xpts, x0, ypts, y0)</p>
</div></blockquote>
<p>and defautls to cartesian distance,</p>
<blockquote>
<div><p>distance = np.sqrt((xpts - x0) ** 2 + (ypts - y0) ** 2)</p>
</div></blockquote>
<p>Points where ypts &lt; y0 are returned as negative along the new dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xpts</strong> (<em>array_like</em>) – x input coordinates</p></li>
<li><p><strong>ypts</strong> (<em>array_like</em>) – y input coordinates</p></li>
<li><p><strong>bearing</strong> (<em>float</em>) – direction along which to measure distance (degrees)</p></li>
<li><p><strong>x0</strong> (<em>float</em>) – x origin of distance</p></li>
<li><p><strong>y0</strong> (<em>float</em>) – y origin of distance</p></li>
<li><p><strong>dfunc</strong> (<em>Object</em>) – distance calculating function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>distance along new dimension</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.haversine">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">haversine</code><span class="sig-paren">(</span><em class="sig-param">lon1</em>, <em class="sig-param">lat1</em>, <em class="sig-param">lon2</em>, <em class="sig-param">lat2</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.haversine" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the great circle distance between two points
on the earth (specified in decimal degrees). Return value
in meters.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.increase_resolution">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">increase_resolution</code><span class="sig-paren">(</span><em class="sig-param">ptsx</em>, <em class="sig-param">ptsy</em>, <em class="sig-param">N</em>, <em class="sig-param">offset_idx=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.increase_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a higher resolution track described in 2D by ptsx and
ptsy, 2 numpy 1D arrays, with N linearly equidistant points
added in between.</p>
<p>ptsx and ptsy are assumed to be longitudes and latitudes and
along track distance from the first point is returned in
km. Example:</p>
<p>trk_lon, trk_lat, trk_dist = points_to_hrtrack(ptsx, ptsy, 100)</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.in_polygon">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">in_polygon</code><span class="sig-paren">(</span><em class="sig-param">x_pts</em>, <em class="sig-param">y_pts</em>, <em class="sig-param">x_poly</em>, <em class="sig-param">y_poly</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a boolean array identifying points of x_pts, y_pts inside
the polygon defined by x_poly,y_poly.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.get_contour_xy">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">get_contour_xy</code><span class="sig-paren">(</span><em class="sig-param">cs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.get_contour_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Let cs be the handle to a contour with one line. This returns
its x,y values.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.project_to_line">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">project_to_line</code><span class="sig-paren">(</span><em class="sig-param">xpt: x input coordinates</em>, <em class="sig-param">ypt: y input coordinates</em>, <em class="sig-param">a: line x term constant</em>, <em class="sig-param">b: line y term constant</em>, <em class="sig-param">c: line constant</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.project_to_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Project data at (xpt, ypt) on line  ax + by + c = 0</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.proximity_group">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">proximity_group</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">D</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.proximity_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Function proxGroup usage:   G,N,I   =   proxGroup(A,D)</p>
<p>Summary:</p>
<blockquote>
<div><p>Proximity grouping of values in an irregular but
monotonically increasing array ‘A’. Adjacent values
are group if the distance between them is less than
or equal to ‘D’. Returned values are the group ID
of each element ‘G’, number of elements per group
‘N’, and index values by group ‘I’.</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.polygon_area">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">polygon_area</code><span class="sig-paren">(</span><em class="sig-param">vecx</em>, <em class="sig-param">vecy</em>, <em class="sig-param">lonlat=False</em>, <em class="sig-param">pos=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.polygon_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Greene’s theorem to compute polygon area. Input vectors
can be longitudes and latitudes if bm is specified. Otherwise
they are assumed coordinates of linear space.</p>
<p>vecx:    array like, horizontal vector in linear space
vecy:    array like, vertical vector in linear space
lonlat:    bool, if input is lonlat, convert to CEA projection
pos: bool, return absolute value, defaults to True</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.rotate_frame">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">rotate_frame</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">ang</em>, <em class="sig-param">units='rad'</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.rotate_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates values of 2D vector space whose component values
are given by u and v.</p>
<dl class="simple">
<dt>u,v:    eastward and northward vector component arrays. Must</dt><dd><p>be of same size, of arbitrary dimension.</p>
</dd>
<dt>ang:    the angle by which you turn the frame of reference</dt><dd><p>positive being anti-clockwise.</p>
</dd>
<dt>units:  units of ang, ‘rad’ (default) for radians and ‘deg’</dt><dd><p>for degrees.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_abs">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_abs</code><span class="sig-paren">(</span><em class="sig-param">ds</em>, <em class="sig-param">field</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dataset ds with field taken absolute.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_unique">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_unique</code><span class="sig-paren">(</span><em class="sig-param">ds</em>, <em class="sig-param">sort_label</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the xarray dataset or dataarry with duplicate values along
dimension sort_label have been removed.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.pd_bin">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">pd_bin</code><span class="sig-paren">(</span><em class="sig-param">dataframe</em>, <em class="sig-param">dimension</em>, <em class="sig-param">grid</em>, <em class="sig-param">func=&lt;function nanmean&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.pd_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around xr_bin to allow bin averaging in pandas
dataframes.</p>
<p>dataframe [pandas dataframe]  : input data
dimesion  [string]            : index along which to bin
grid      [array-like]        : bin centers
func      [callable]          : function to pass xrutils.xr_bin</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_bin">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_bin</code><span class="sig-paren">(</span><em class="sig-param">ds</em>, <em class="sig-param">dim</em>, <em class="sig-param">binc</em>, <em class="sig-param">func=&lt;function nanmean&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Function xr_bin usage:  ds = xr_bin(ds, dim, binc, func=numpy.nanmean)</p>
<p>Wrapper function for the groupby_bins xarray method. Meant for
simply binning xarray ds to the values of dimension dim, and
return values at bin centers binc.</p>
<p>ds: input Dataset of DataArray
dim: string: name of dimension along which to bin
binc: array: bin centers
func: callable: reducing function, defaults to numpy.nanmean</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_filter">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_filter</code><span class="sig-paren">(</span><em class="sig-param">coord</em>, <em class="sig-param">val</em>, <em class="sig-param">fc</em>, <em class="sig-param">btype='high'</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">order=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function xrflt usage:   da  =  xrflt(coord,val,fc,btype=’high’,axis=-1,order=1)</p>
<p>Summary:</p>
<blockquote>
<div><p>Wrapper of scipy.signal.filtfilt that takes for input a coordinate
DataArray and a val DataArray. Returns a DataArray of the filtered
val values along the initial coordinate. Cutoff frequency should be
supplied in seconds -1.</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_godin">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_godin</code><span class="sig-paren">(</span><em class="sig-param">dataarray</em>, <em class="sig-param">tname</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_godin" title="Permalink to this definition">¶</a></dt>
<dd><p>Tide killing Godin filter of dataarray along dimension ‘tname’.</p>
</dd></dl>

<dl class="function">
<dt id="mxtoolbox.process.xr_peaks">
<code class="sig-prename descclassname">mxtoolbox.process.</code><code class="sig-name descname">xr_peaks</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">th_array</em>, <em class="sig-param">tname</em>, <em class="sig-param">two_sided=True</em>, <em class="sig-param">fp_kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mxtoolbox.process.xr_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Function xrPks usage:   out  =  xrPks(array,th_array,tname,two_sided=True,fp_kwargs=None)</p>
<p>Summary:</p>
<blockquote>
<div><p>Wrapper of scipy.signal.find_peaks that takes as input the array in which
to find peaks, the variable threshold array ‘th_array’ and their matching
x coordinate name ‘tname’. If two_sided is True, positive and negative peaks
above the threshold will be returned.</p>
<p>out is a tuple formed of DataArrays for high peaks, low peaks (two_sided=True), and
index of peaks in original array.</p>
</div></blockquote>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">mxtoolbox</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mxtoolbox.process</span></code></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to mxtoolbox’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Jean-Luc Shaw.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/process.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>